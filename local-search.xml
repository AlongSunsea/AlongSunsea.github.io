<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>js原型与原型链</title>
    <link href="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JS原型与原型链"><a href="#一、JS原型与原型链" class="headerlink" title="一、JS原型与原型链"></a>一、JS原型与原型链</h1><h2 id="（1）JS原型"><a href="#（1）JS原型" class="headerlink" title="（1）JS原型"></a>（1）JS原型</h2><h3 id="①函数对象"><a href="#①函数对象" class="headerlink" title="①函数对象"></a>①函数对象</h3><p>​所有引用类型（Object，Array，Date，Function），都拥有__ proto__(隐式原型)属性，属性值为一个普通的对象。</p><p>​所有函数都拥有prototype属性（显示原型），为函数所特有的属性。</p><p>​原型对象：即prototype属性指向的对象叫做原型对象，当申明一个函数的时候，编译器会自动帮你创建一个与之对应的对象称为原型对象。 每个函数都有一个prototype属性,它是一个指针,指向一个对象,这个对象包含了所有实例共享的属性和方法。</p><h3 id="②构造函数"><a href="#②构造函数" class="headerlink" title="②构造函数"></a>②构造函数</h3><p>​首先先构造一个函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name,age)</span>&#123;<br>     <span class="hljs-keyword">this</span>.name=name;<br>     <span class="hljs-keyword">this</span>.age=age;<br>&#125;<br></code></pre></td></tr></table></figure><p>​往原型对象里面添加成员。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Person.prototype.eat=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br>Person.prototype.study=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="③实例化对象"><a href="#③实例化对象" class="headerlink" title="③实例化对象"></a>③实例化对象</h3><p>通过new关键字，构建p1，p2实例对象。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">let</span> p<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> p<span class="hljs-number">2</span> = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>此时p1，p2可以访问构造函数的原型上的方法，并且p1.eat &#x3D;&#x3D;&#x3D;  p2.eat。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">p1.eat()<span class="hljs-comment">;   //输出&quot;我要干饭！&quot;</span><br>console.log(p1.eat<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>p2.eat)<span class="hljs-comment">;  //输出：true</span><br></code></pre></td></tr></table></figure><p>但注意如果没有使用往原型对象里面添加成员的方法，直接在构造函数内添加方法，在通过实例化对象调用该方法，此时二者<strong>不相等</strong>！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">20</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">study</span>===p2.<span class="hljs-property">study</span>);   <span class="hljs-comment">//此时输出：false</span><br></code></pre></td></tr></table></figure><p>这是因为，构造函数的定义方法在实例对象上都创建一遍，上方代码p1和p2都有名为study的方法，但是这两个方法不是同一个Function的实例。实例共享的属性和方法都放在原型对象上，有效解决构造函数内存资源浪费 + 全局变量污染。</p><h3 id="④-proto-属性"><a href="#④-proto-属性" class="headerlink" title="④ __proto__属性"></a>④ <code>__proto__</code>属性</h3><p><code>__proto__</code>:  属于实例对象，可以让实例对象访问原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span>===<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);   <span class="hljs-comment">//此时输出：true</span><br></code></pre></td></tr></table></figure><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/01.png" alt="图1"></p><h3 id="⑤constructor属性"><a href="#⑤constructor属性" class="headerlink" title="⑤constructor属性"></a>⑤constructor属性</h3><p>constructor属性，属于原型对象，指向构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Person</span>); <span class="hljs-comment">//输出为：true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">//输出为：true</span><br></code></pre></td></tr></table></figure><p><code>p1.__proto__.constructor</code>可以直接写为<code>p1.constructor</code>，p1可以直接访问原型对象。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/02.png" alt="图2"></p><h2 id="（2）js原型链"><a href="#（2）js原型链" class="headerlink" title="（2）js原型链"></a>（2）js原型链</h2><h3 id="①引用一个例子"><a href="#①引用一个例子" class="headerlink" title="①引用一个例子"></a>①引用一个例子</h3><p>原型链：每一个对象都有原型，而原型也是对象，也会有自己的原型。以此类推形成链式结构，称之为原型链。</p><p>观察以下代码输出结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>);  <span class="hljs-comment">//输出：张三</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">age</span>);<span class="hljs-comment">//输出：18</span><br>p1.<span class="hljs-title function_">eat</span>();<span class="hljs-comment">//输出：我要干饭！</span><br>p1.<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//不报错</span><br>p1.<span class="hljs-title function_">learn</span>();<span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><p>引用<code>p1.eat()</code>，p1的构造函数的原型对象有eat方法，正常输出。但是p1的构造函数的原型对象上没有learn和toString方法，引用<code>p1.learn()</code>，输出报错，调用<code>p1.toString()</code>输出却不报错。这是因为，当调用<code>p1.toString()</code>方法时，p1的构造函数的原型对象上没有toString方法，但是p1的构造函数的<strong>原型对象的原型对象上</strong>有toString方法。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/03.png" alt="图3"></p><p>检查p1原型的原型。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/04.png" alt="图4"></p><p>检查p1原型的原型的原型。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/05.png" alt="图5"></p><p>发现原型链终点为<code>null</code>。</p><h3 id="②画出原型链。"><a href="#②画出原型链。" class="headerlink" title="②画出原型链。"></a>②画出原型链。</h3><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/06.png" alt="图6"></p><h1 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h1><p>（1）、我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是对象所独有的；②<code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p><p>（2）、<code>prototype</code>属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即p1.<code>__proto__</code> &#x3D;&#x3D;&#x3D; <code>Person.prototype</code>。</p><p>（3）、<code>__proto__</code>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点null，再往上找就相当于在null上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p><p>（4）、<code>constructor</code>属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue2后台管理总结</title>
    <link href="/2023/06/19/vue2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <url>/2023/06/19/vue2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="vue2后台管理总结"><a href="#vue2后台管理总结" class="headerlink" title="vue2后台管理总结"></a>vue2后台管理总结</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>​这个项目已经做了挺久一段时间了，但是一直也没有花时间来总结一下，只是做完了，就不管了，前端老组长就跟我说了项目无非就是tob和toc，好吧刚听到这两个词一脸懵，他跟我解释也就是前台和中后台项目。这个后台管理项目是我第一个完整完成的，做的时候其中有一些地方没搞懂也就过去了，回过头来重新总结分析一下吧。</p><h2 id="二、前期准备"><a href="#二、前期准备" class="headerlink" title="二、前期准备"></a>二、前期准备</h2><p>Node环境</p><p>安装@vue&#x2F;cli</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i @vue/cli -g<br></code></pre></td></tr></table></figure><p>创建脚手架</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">vue <span class="hljs-keyword">create</span> 脚手架文件夹名<br></code></pre></td></tr></table></figure><h3 id="采用ElementUI组件库，网络请求axios库。"><a href="#采用ElementUI组件库，网络请求axios库。" class="headerlink" title="采用ElementUI组件库，网络请求axios库。"></a>采用ElementUI组件库，网络请求axios库。</h3><ol><li><p>下载element-ui包到当前项目(注意它支持的是Vue2版本项目)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">npm i <span class="hljs-built_in">add</span> <span class="hljs-keyword">element</span>-ui<br></code></pre></td></tr></table></figure></li><li><p>封装新建<code>src/elementUI/index.js</code>, 在这里进行组件引入和注册</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> ElementUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><br>Vue.use(ElementUI)<br></code></pre></td></tr></table></figure></li><li><p>在main.js中引入, 使其参与到webpack打包并在网页生效</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@/elementUI&#x27;</span> <span class="hljs-comment">// 注册elementUI组件</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="封装请求库的思想"><a href="#封装请求库的思想" class="headerlink" title="封装请求库的思想"></a>封装请求库的思想</h3><p>封装项目的请求架构，为后面的请求数据做准备</p><p>项目管理网络请求：</p><p>1）下载axios包到当前项目的文件夹中</p><p>2）封装request请求函数配置基地址</p><p>3）封装api统一接口方法</p><p>4）在逻辑页面，需要用到哪个就引入后调用等待请求的结果，在逻辑页面使用后台返回的数据。</p><p>核心思想：<strong>分层架构</strong></p><p>在任意组件调用封装好的接口方法，接口方法调用统一的axios函数告诉他请求的参数它去请求数据。</p><p><img src="/2023/06/19/vue2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/axios.png" alt="请求结构"></p><p>安装axios：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i axios<br></code></pre></td></tr></table></figure><p>新建<code>src/utils/request.js</code>项目核心请求方法的模块文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 创建一个自定的axios方法(比原axios多了个基地址)</span><br><span class="hljs-comment">// axios函数请求的url地址前面会被拼接基地址, 然后axios请求baseURL+url后台完整地址</span><br><span class="hljs-keyword">const</span> myAxios = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://big-event-vue-api-t.itheima.net&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">// 导出自定义的axios方法, 供外面调用传参发请求</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> myAxios<br></code></pre></td></tr></table></figure><p>新建<code>src/api/index.js</code>项目接口方法的统一管理模块文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/request.js&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getList</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-comment">// 这里先用这个接口测试下, 如果url以http开头会忽略baseURL, axios直接请求此地址</span><br><span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>        <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://geek.itheima.net/v1_0/channels&#x27;</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在任意组件<code>src/App.vue</code>中引入接口请求方式，并请求数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;getList&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getListFn</span>()<br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">getListFn</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getListAPI</span>()<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种分层架构思想, 可以更好的统一管理项目中所有接口, 并也方便统一给axios方法添加拦截器和修改基地址</p>]]></content>
    
    
    
    <tags>
      
      <tag>vue项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂感</title>
    <link href="/2023/06/18/%E6%9D%82%E6%84%9F/"/>
    <url>/2023/06/18/%E6%9D%82%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="杂感"><a href="#杂感" class="headerlink" title="杂感"></a>杂感</h1><p>好久没有更新博客了，经过和老组长交流了一下，以后要坚持持续更新，看了一眼老组长的博客，真的感慨，千里之行始于足下，回想这一学期的学习，我感觉真的学的东西太少了！虽然每天坚持到实验室打卡，不过有效学习的时间真的不多，转眼就大三了，希望能在这个暑假有所收获！加油！</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js原型与原型链</title>
    <link href="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JS原型与原型链"><a href="#一、JS原型与原型链" class="headerlink" title="一、JS原型与原型链"></a>一、JS原型与原型链</h1><h2 id="（1）JS原型"><a href="#（1）JS原型" class="headerlink" title="（1）JS原型"></a>（1）JS原型</h2><h3 id="①函数对象"><a href="#①函数对象" class="headerlink" title="①函数对象"></a>①函数对象</h3><p>​所有引用类型（Object，Array，Date，Function），都拥有__ proto__(隐式原型)属性，属性值为一个普通的对象。</p><p>​所有函数都拥有prototype属性（显示原型），为函数所特有的属性。</p><p>​原型对象：即prototype属性指向的对象叫做原型对象，当申明一个函数的时候，编译器会自动帮你创建一个与之对应的对象称为原型对象。 每个函数都有一个prototype属性,它是一个指针,指向一个对象,这个对象包含了所有实例共享的属性和方法。</p><h3 id="②构造函数"><a href="#②构造函数" class="headerlink" title="②构造函数"></a>②构造函数</h3><p>​首先先构造一个函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name,age)</span>&#123;<br>     <span class="hljs-keyword">this</span>.name=name;<br>     <span class="hljs-keyword">this</span>.age=age;<br>&#125;<br></code></pre></td></tr></table></figure><p>​往原型对象里面添加成员。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Person.prototype.eat=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br>Person.prototype.study=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="③实例化对象"><a href="#③实例化对象" class="headerlink" title="③实例化对象"></a>③实例化对象</h3><p>通过new关键字，构建p1，p2实例对象。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">let</span> p<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> p<span class="hljs-number">2</span> = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>此时p1，p2可以访问构造函数的原型上的方法，并且p1.eat &#x3D;&#x3D;&#x3D;  p2.eat。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">p1.eat()<span class="hljs-comment">;   //输出&quot;我要干饭！&quot;</span><br>console.log(p1.eat<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>p2.eat)<span class="hljs-comment">;  //输出：true</span><br></code></pre></td></tr></table></figure><p>但注意如果没有使用往原型对象里面添加成员的方法，直接在构造函数内添加方法，在通过实例化对象调用该方法，此时二者<strong>不相等</strong>！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">20</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">study</span>===p2.<span class="hljs-property">study</span>);   <span class="hljs-comment">//此时输出：false</span><br></code></pre></td></tr></table></figure><p>这是因为，构造函数的定义方法在实例对象上都创建一遍，上方代码p1和p2都有名为study的方法，但是这两个方法不是同一个Function的实例。实例共享的属性和方法都放在原型对象上，有效解决构造函数内存资源浪费 + 全局变量污染。</p><h3 id="④-proto-属性"><a href="#④-proto-属性" class="headerlink" title="④ __proto__属性"></a>④ <code>__proto__</code>属性</h3><p><code>__proto__</code>:  属于实例对象，可以让实例对象访问原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span>===<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);   <span class="hljs-comment">//此时输出：true</span><br></code></pre></td></tr></table></figure><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/01.png" alt="图1"></p><h3 id="⑤constructor属性"><a href="#⑤constructor属性" class="headerlink" title="⑤constructor属性"></a>⑤constructor属性</h3><p>constructor属性，属于原型对象，指向构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Person</span>); <span class="hljs-comment">//输出为：true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">//输出为：true</span><br></code></pre></td></tr></table></figure><p><code>p1.__proto__.constructor</code>可以直接写为<code>p1.constructor</code>，p1可以直接访问原型对象。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/02.png" alt="图2"></p><h2 id="（2）js原型链"><a href="#（2）js原型链" class="headerlink" title="（2）js原型链"></a>（2）js原型链</h2><h3 id="①引用一个例子"><a href="#①引用一个例子" class="headerlink" title="①引用一个例子"></a>①引用一个例子</h3><p>原型链：每一个对象都有原型，而原型也是对象，也会有自己的原型。以此类推形成链式结构，称之为原型链。</p><p>观察以下代码输出结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>);  <span class="hljs-comment">//输出：张三</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">age</span>);<span class="hljs-comment">//输出：18</span><br>p1.<span class="hljs-title function_">eat</span>();<span class="hljs-comment">//输出：我要干饭！</span><br>p1.<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//不报错</span><br>p1.<span class="hljs-title function_">learn</span>();<span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><p>引用<code>p1.eat()</code>，p1的构造函数的原型对象有eat方法，正常输出。但是p1的构造函数的原型对象上没有learn和toString方法，引用<code>p1.learn()</code>，输出报错，调用<code>p1.toString()</code>输出却不报错。这是因为，当调用<code>p1.toString()</code>方法时，p1的构造函数的原型对象上没有toString方法，但是p1的构造函数的<strong>原型对象的原型对象上</strong>有toString方法。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/03.png" alt="图3"></p><p>检查p1原型的原型。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/04.png" alt="图4"></p><p>检查p1原型的原型的原型。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/05.png" alt="图5"></p><p>发现原型链终点为<code>null</code>。</p><h3 id="②画出原型链。"><a href="#②画出原型链。" class="headerlink" title="②画出原型链。"></a>②画出原型链。</h3><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/06.png" alt="图6"></p><h1 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h1><p>（1）、我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是对象所独有的；②<code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p><p>（2）、<code>prototype</code>属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即p1.<code>__proto__</code> &#x3D;&#x3D;&#x3D; <code>Person.prototype</code>。</p><p>（3）、<code>__proto__</code>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点null，再往上找就相当于在null上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p><p>（4）、<code>constructor</code>属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

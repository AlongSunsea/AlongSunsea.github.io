<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前后端交互-搜索框模糊查询</title>
    <link href="/2023/09/19/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92-%E6%90%9C%E7%B4%A2%E6%A1%86%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/"/>
    <url>/2023/09/19/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92-%E6%90%9C%E7%B4%A2%E6%A1%86%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前后端交互-搜索框模糊查询"><a href="#前后端交互-搜索框模糊查询" class="headerlink" title="前后端交互-搜索框模糊查询"></a>前后端交互-搜索框模糊查询</h1><p><strong>记录一下常见功能前后端交互的搜索框模糊查询。</strong></p><p>大致思路：当前端点击搜索功能，获取到搜索框内的内容，携带请求的参数向后端发送网络请求，后端接收到网络请求，根据前端带来请求参数，根据次参数进行数据库语句查询。</p><img src="/2023/09/19/%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92-%E6%90%9C%E7%B4%A2%E6%A1%86%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/整体流程.png" alt="交互流程" style="zoom: 67%;"><p>前端–&gt;后端：给搜索按钮添加点击事件，跳转路由来到搜索页，并携带参数<code>key</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">this.$router.push(&#123;<br>         name:&#x27;list&#x27;,<br>         query:&#123;<br>             key:this.searchVal<br>        &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>跳转路由后创建组件时调用请求接口函数：将路由携带的参数传递给后端。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">created()&#123;<br>   this.getData()<br>&#125;,<br>   methods:&#123;<br>      getData()&#123;<br>          http.$axios(&#123;<br>               url:&#x27;/api/goods/shopList&#x27;,<br>               params:&#123;<br>                    searchName:this.$route.query.key<br>               &#125;<br>          &#125;).then(res=&gt;&#123;<br>                this.goodsList=res<br>                console.log(res);<br>          &#125;)<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>http.$axios</code>为二次封装的axios，具体操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs vue">import axios from &#x27;axios&#x27;<br>// 引入mint-ui里的Indicator，在相应数据时出现小动画<br>import &#123;Indicator&#125; from &#x27;mint-ui&#x27;<br>export default &#123;<br>    common:&#123;<br>        method:&#x27;GET&#x27;,<br>        data:&#123;&#125;,<br>        params:&#123;&#125;<br>    &#125;,<br>    $axios(option=&#123;&#125;)&#123;<br>        option.method = option.method || this.common.method;<br>        option.data = option.data || this.common.data;<br>        option.params = option.params || this.common.params;<br><br>        Indicator.open(&#x27;加载中...&#x27;)<br>        return axios(option).then(v=&gt;&#123;<br>            let data = v.data.data<br>            return new Promise((res,rej)=&gt;&#123;<br>                if(!v) return rej()<br>                Indicator.close()<br>                res(data)<br>            &#125;)<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后端接收前端请求里的数据参数（使用express框架）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">var express = require(&#x27;express&#x27;);<br>var router = express.Router();<br>// 引入连接数据库<br>var connection = require(&#x27;../db/sql.js&#x27;)<br>// 查询搜索接口<br>router.get(&#x27;/api/goods/shopList&#x27;,function(req,res,next)&#123;<br>  let searchName= req.query.searchName<br>  // 模糊查询<br>  connection.query(&#x27;select * from goods_list where name like &quot;%&#x27;+searchName+&#x27;%&quot;&#x27;,function(err,results)&#123;<br>    console.log(err);<br>// 返回匹配到的数据给前端<br>    res.send(&#123;<br>      code:0,<br>      data:results<br>    &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>连接数据库：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> mysql = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mysql&#x27;</span>)<br><span class="hljs-keyword">let</span> connection = mysql.<span class="hljs-title function_">createConnection</span>(&#123;<br>    <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    <span class="hljs-attr">user</span>:<span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;admin123&#x27;</span>,<br>    <span class="hljs-attr">database</span>:<span class="hljs-string">&#x27;vue-tea-store&#x27;</span><br>&#125;)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = connection;<br></code></pre></td></tr></table></figure><p>这里连接时报错，查了原因是因为MySQL 8.0默认的密码验证模式，与node的默认密码验证模式不一致导致无法连接数据库报错。</p><p>解决办法：修改验证模式</p><p>打开终端，输入以下命令和密码，连接MySQL。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u root -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>输入以下SQL语句，修改验证模式和密码。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> &quot;root&quot;@&quot;localhost&quot; IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> &quot;password&quot;;<br></code></pre></td></tr></table></figure><p>输入以下SQL语句，刷新权限，使修改立即生效。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FLUSH PRIVILEGES<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>退出MySQL。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span>;<br></code></pre></td></tr></table></figure><p>前端根据相应的数据进行渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">getData()&#123;<br>    http.$axios(&#123;<br>         url:&#x27;/api/goods/shopList&#x27;,<br>         params:&#123;<br>              searchName:this.$route.query.key<br>         &#125;<br>    &#125;).then(res=&gt;&#123;<br>          this.goodsList=res<br>          console.log(res);<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>拿到响应数据赋值给<code>this.goodsList</code>，列表根据 <code>this.goodsList</code>进行数据渲染。</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中的继承</title>
    <link href="/2023/09/11/JS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <url>/2023/09/11/JS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="JS中的继承"><a href="#JS中的继承" class="headerlink" title="JS中的继承"></a>JS中的继承</h1><h3 id="1-ES5继承"><a href="#1-ES5继承" class="headerlink" title="1.ES5继承"></a>1.ES5继承</h3><h4 id="①原型链继承"><a href="#①原型链继承" class="headerlink" title="①原型链继承"></a>①原型链继承</h4><p>原型链继承的核心思想，就是将父亲的实例作为子类的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义父类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent&#x27;</span><br>&#125;<br><span class="hljs-comment">// 在父类的原型上定义方法</span><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-comment">// 定义子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;child&quot;</span><br>&#125;<br><span class="hljs-comment">// 子类的原型=父亲的实例</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-comment">// 实例化子类</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Child1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child1</span>.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// child</span><br></code></pre></td></tr></table></figure><p><strong>缺点：</strong></p><p>在使用原型链继承时，父类的引用数据类型（对象、数组）会被子类共享，子类实例数据更改，其他子类也会受到变化。并且子类实例不能给父类构造函数传参。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-comment">// 在父类的原型上定义方法</span><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-comment">// 定义子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>)&#123;<br>&#125;<br><span class="hljs-comment">// 子类的原型=父亲的实例</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br><br><span class="hljs-comment">// 实例化子类</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Child1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Child2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-title class_">Child1</span>.<span class="hljs-property">name</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child1</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// [1, 2, 3, 4]   </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child2</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// [1, 2, 3, 4]   child2.name受到改变</span><br></code></pre></td></tr></table></figure><p><strong>tips：</strong>引用类型在JavaScript中是按引用传递的，也就是说当我们将一个引用类型赋值给另一个变量时，实际上是将引用地址传递给了新的变量，而不是将实际的对象复制一份。因此，通过一个变量修改引用类型的属性时，其他引用该对象的变量也会反映出这个修改。</p><p>当使用原型链继承时，子对象会通过原型链继承父对象的属性和方法，这些属性和方法在子对象中只是指向同一个引用。所以，如果我们修改了子对象中的引用类型属性，其实是修改了原型链上的那个引用，因此其他通过原型链继承的对象也会受到影响。</p><h4 id="②构造函数继承"><a href="#②构造函数继承" class="headerlink" title="②构造函数继承"></a>②构造函数继承</h4><p>构造函数继承的思想：在子类构造函数中调用父类构造函数，使用apply()或者call()方法创建新的对象为上下文执行构造函数。等于是复制父类的实例属性给子类（没用到原型）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造函数继承</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">arg</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = arg<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-comment">// 在父亲原型上定义方法</span><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;<br><span class="hljs-comment">// 定义子类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">// 使用call方法</span><br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-string">&#x27;参数&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// 实例化子类</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Child1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Child2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child1</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">//--&gt;&#x27;参数&#x27;</span><br><span class="hljs-title class_">Child2</span>.<span class="hljs-property">arr</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child1</span>.<span class="hljs-property">arr</span>); <span class="hljs-comment">// [1, 2, 3, 4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child2</span>.<span class="hljs-property">arr</span>); <span class="hljs-comment">// [1, 2, 3] </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child1</span>.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>使用构造函数继承：父类的引用类型的数据不会被子类共享，并且可以传递参数。</p><p>缺点：子类不能访问父类原型属性上的方法和参数。</p><h4 id="③组合继承"><a href="#③组合继承" class="headerlink" title="③组合继承"></a>③组合继承</h4><p>组合继承综合了原型链和构造函数，基本思路：使用原型链来继承父类原型上的属性和方法，使用构造函数继承实例属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 组合继承</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params">arg</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = arg<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&#125;<br><span class="hljs-comment">// 在父亲原型上定义方法</span><br><span class="hljs-title class_">Parent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;父亲原型上的方法&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 定义子类 通过构造函数继承实例</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,<span class="hljs-string">&#x27;参数&#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 通过原型链继承父类原型上的属性方法（子类的原型等于父类的实例）</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>()<br><span class="hljs-comment">// 实例化子类</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Child1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Child2</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>()<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child1</span>.<span class="hljs-property">name</span>);<br><span class="hljs-title class_">Child2</span>.<span class="hljs-property">arr</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child1</span>.<span class="hljs-property">arr</span>); <span class="hljs-comment">// [1, 2, 3, 4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child2</span>.<span class="hljs-property">arr</span>); <span class="hljs-comment">// [1, 2, 3]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child1</span>.<span class="hljs-title function_">getName</span>() ); <span class="hljs-comment">//--&gt;打印&#x27;父亲原型上的方法&#x27;</span><br></code></pre></td></tr></table></figure><p>使用组合继承，综合了原型链继承和构造函数继承的优点，父类中的引用类型数据不会被子类共享，子类可以传参，也可以获取父类原型上的属性和方法。</p><p><strong>缺点：</strong>出现效率问题，会调用两次父类的构造函数，一次是在创建子类原型时，一次是在子类构造函数时，会有两份一样的属性方法。</p><p>我们打印子类实例<code>console.log(Child1);</code></p><img src="/2023/09/11/JS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/组合继承.png" alt="组合继承缺点" style="zoom:150%;"><h4 id="④原型式继承"><a href="#④原型式继承" class="headerlink" title="④原型式继承"></a>④原型式继承</h4><p>原型式继承首先了解ES5里<code>Object.create</code>方法，第一个参数是作为新对象原型的对象，第二个可选参数是给新对象定义额外属性对象。本质是对第一个参数对象的浅复制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">//  原型式继承</span><br> <span class="hljs-keyword">let</span> <span class="hljs-title class_">Parent</span> = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;Pa&#x27;</span>,<br>    <span class="hljs-attr">arr</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],<br>    <span class="hljs-attr">printArr</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Parent</span>,&#123;<br>    <span class="hljs-attr">name</span>:&#123;<br>        <span class="hljs-attr">value</span>:<span class="hljs-string">&#x27;pa2&#x27;</span><br>    &#125;<br>&#125;)<br><span class="hljs-title class_">Child</span>.<span class="hljs-title function_">printArr</span>() <span class="hljs-comment">//[1,2,3,4]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Child</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// pa2</span><br></code></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>父类的引用属性会被所有子类实例共享</li><li>子类构建实例时不能向父类传递参数</li></ul><p>适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。</p><h4 id="⑤寄生式继承"><a href="#⑤寄生式继承" class="headerlink" title="⑤寄生式继承"></a>⑤寄生式继承</h4><p>使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>  <span class="hljs-title function_">createAnother</span>(<span class="hljs-params">original</span>)&#123;<br>    <span class="hljs-keyword">let</span> clone = <span class="hljs-title class_">Object</span>(original)<br>    clone.<span class="hljs-property">sayHi</span>= <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> clone<br>&#125;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;he&#x27;</span>,<br>    <span class="hljs-attr">age</span>:<span class="hljs-number">18</span><br>&#125;<br><span class="hljs-keyword">let</span> person1 = <span class="hljs-title function_">createAnother</span>(person)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1)<br></code></pre></td></tr></table></figure><p>通过寄生式继承给对象添加函数会导致函数难以复用。</p><h4 id="⑥寄生式组合继承"><a href="#⑥寄生式组合继承" class="headerlink" title="⑥寄生式组合继承"></a>⑥寄生式组合继承</h4><p>寄生式组合继承<strong>通过构造函数继承属性</strong>，但使用<strong>混合式原型链继承方法</strong>。基本思路：不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 寄生式组合继承</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><br><span class="hljs-comment">// 父类原型</span><br><span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`你好，我叫<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params">name</span>)&#123;<br>    <span class="hljs-title class_">Father</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>,name)<br>&#125;<br><br><span class="hljs-comment">// 基于父类原型创建一个新的原型对象，原型的构造函数指向子类</span><br><span class="hljs-keyword">const</span> prototype = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-title class_">Father</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,&#123;<br>    <span class="hljs-attr">construcor</span>:&#123;<br>        <span class="hljs-attr">value</span>:<span class="hljs-title class_">Child</span><br>    &#125;<br>&#125;)<br><span class="hljs-comment">// 新的原型对象赋值给子类的原型，</span><br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>=prototype<br><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Child1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>(<span class="hljs-string">&#x27;111&#x27;</span>)<br></code></pre></td></tr></table></figure><p>组合式继承：借用构造函数，原型链</p><p>寄生：父亲的原型中，有子类的构造函数。</p><img src="/2023/09/11/JS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/寄生组合式继承.png" alt="寄生式组合继承"><p>只调用一次父类构造函数，避免<code>Child.prototype</code>上重复的属性和方法，效率高，原型键也保持不变。</p><h3 id="2-ES6类的继承"><a href="#2-ES6类的继承" class="headerlink" title="2.ES6类的继承"></a>2.ES6类的继承</h3><h4 id="①class"><a href="#①class" class="headerlink" title="①class"></a>①class</h4><p>ECMAScript6新引入<code>class</code>关键字具有正式定义类的能力，实际背后使用的仍然是原型和构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// 公有属性</span><br>    name<br>    age=<span class="hljs-number">18</span><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br>        <span class="hljs-comment">// 构造函数内部的this 就是实例化对象</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>        <span class="hljs-comment">// 可以动态添加属性，但是不推荐</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">foods</span> = [<span class="hljs-string">&#x27;西蓝花&#x27;</span>,<span class="hljs-string">&#x27;鸡蛋&#x27;</span>]<br>    &#125;<br>    <span class="hljs-comment">// 公有方法</span><br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;你好&#x27;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 基于类实例化对象</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;he&#x27;</span>)<br></code></pre></td></tr></table></figure><p>私有属性和静态方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 静态属性， 访问时：类来访问</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-comment">// 定义时：static开头</span><br>    <span class="hljs-keyword">static</span> stInfo=<span class="hljs-string">&#x27;我是静态属性&#x27;</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">stMethod</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是静态方法&#x27;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 私有属性方法</span><br>    #prInfo = <span class="hljs-string">&#x27;我是私有属性&#x27;</span><br>    #<span class="hljs-title function_">prMethod</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我是私有方法&#x27;</span>)<br>    &#125;<br>    <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.#prInfo)<br>        <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">prMethod</span>()<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 类调用</span><br><span class="hljs-title class_">Test</span>.<span class="hljs-title function_">stMethod</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Test</span>.<span class="hljs-property">stInfo</span>);<br><span class="hljs-keyword">const</span> t=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>()<br>t.<span class="hljs-title function_">testPr</span>()<br>t.#<span class="hljs-title function_">prMethod</span>() <span class="hljs-comment">// 访问私有属性，方法会报错</span><br></code></pre></td></tr></table></figure><h4 id="②class继承"><a href="#②class继承" class="headerlink" title="②class继承"></a>②class继承</h4><p>extends：使用extends可以继承任何拥有[[Construct]]和原型的对象。</p><p>super：一般用来调用父类的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    name<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>    &#125;<br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;父亲的sayHi&#x27;</span>);<br>    &#125;        <br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-comment">// extends：继承父类</span><br><span class="hljs-comment">// super：一般用来调用父亲的构造函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>    age<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name,age</span>)&#123;<br>        <span class="hljs-comment">// 用super调用父类构造函数，不要在super()之前引用this，否则报错 </span><br>        <span class="hljs-variable language_">super</span>(name)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age<br>    &#125;<br>    <span class="hljs-comment">// 给子类添加方法</span><br>    <span class="hljs-title function_">sayHello</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;子类的方法&#x27;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 同名方法就近</span><br>    <span class="hljs-title function_">sayHi</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;子类的sayHi&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> son1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&#x27;son1&#x27;</span>,<span class="hljs-number">18</span>)<br><span class="hljs-keyword">let</span> son2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>(<span class="hljs-string">&#x27;son2&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写call,apply,bind</title>
    <link href="/2023/09/07/call-apply-bind/"/>
    <url>/2023/09/07/call-apply-bind/</url>
    
    <content type="html"><![CDATA[<h1 id="手写call，apply，bind"><a href="#手写call，apply，bind" class="headerlink" title="手写call，apply，bind"></a>手写call，apply，bind</h1><h3 id="1-手写call函数"><a href="#1-手写call函数" class="headerlink" title="1.手写call函数"></a>1.手写call函数</h3><p>实现call函数首先了解call函数的作用：<code>call()</code>方法使用一个<strong>指定的<code>this</code>值</strong>和<strong>单独给出的一个</strong>或者<strong>多个参数</strong>来<strong>调用一个函数</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">numA,numB</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-keyword">return</span> numA + numB<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;定义一个sum函数&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> res = func.<span class="hljs-title function_">call</span>(sum,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)   <span class="hljs-comment">//这里会直接调用func函数，并且func里的this指向sum</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;返回值为&#x27;</span>,res);<br></code></pre></td></tr></table></figure><p>手写call函数，任何函数都可以调用它，在函数<code>Function</code>的原型上加上自己手写的call函数，具体操作如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params">ctx,...args</span>)&#123;<br>    <span class="hljs-comment">// 如果ctx是undefined或者null指向全局对象，否则以对象方式</span><br>    ctx = (ctx===<span class="hljs-literal">undefined</span>||ctx===<span class="hljs-literal">null</span>?<span class="hljs-attr">globalThis</span>:<span class="hljs-title class_">Object</span>(ctx))<br>    <span class="hljs-comment">// 用Symbol来防止ctx有相同属性</span><br>    <span class="hljs-keyword">let</span> key = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br>    <span class="hljs-comment">// 使用属性描述符将调用的函数(func)放到ctx属性里面</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(ctx,key,&#123;<br>        <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">value</span>:<span class="hljs-variable language_">this</span>,<br>        <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span><br>    &#125;)<br>    <span class="hljs-comment">// 调用函数 此时this指向ctx，</span><br>    <span class="hljs-keyword">let</span> result = ctx[key](...args)<br>    <span class="hljs-keyword">delete</span> ctx[key]<br>    <span class="hljs-comment">// 函数有返回值就返回返回值</span><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">numA,numB</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-keyword">return</span> numA + numB<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;定义一个sum函数&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> res2 = func.<span class="hljs-title function_">myCall</span>(sum,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)  <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;返回值为&#x27;</span>,res);<br></code></pre></td></tr></table></figure><p>tips：<code>Symbol</code>是ES6新增的一种数据类型，每个从<code>Symbol()</code>返回的<code>Symbol</code>值都是唯一的，用来作为对象属性的标志符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s1 = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-keyword">const</span> s2 = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s1===s2); <span class="hljs-comment">// false</span><br><span class="hljs-keyword">const</span> s3 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br><span class="hljs-keyword">const</span> s4 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;test&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s3===s4);   <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="2-手写apply函数"><a href="#2-手写apply函数" class="headerlink" title="2.手写apply函数"></a>2.手写apply函数</h3><p>apply函数和call函数非常类似，只是第二个参数是一个数组。apply函数的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">numA,numB</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-keyword">return</span> numA + numB<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;定义一个sum函数&#x27;</span><br>&#125;  <br><span class="hljs-keyword">const</span> res = func.<span class="hljs-title function_">apply</span>(sum,[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>])  <span class="hljs-comment">// 这里第二个参数是一个数组</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;返回值为&#x27;</span>,res); <br></code></pre></td></tr></table></figure><p>手写apply函数也跟call大致相似。在函数对象原型上定义的<code>myApply</code>第二参数不需要用剩余参数的形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在函数原型上定义myApply，myApply第二个参数是一个数组</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ctx,args</span>)&#123;<br>    ctx = (ctx===<span class="hljs-literal">undefined</span>||ctx===<span class="hljs-literal">null</span>?<span class="hljs-attr">globalThis</span>:<span class="hljs-title class_">Object</span>(ctx))<br>    <span class="hljs-keyword">let</span> key = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;key&#x27;</span>)<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(ctx,key,&#123;<br>        <span class="hljs-attr">enumerable</span>:<span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">value</span>:<span class="hljs-variable language_">this</span>,<br>        <span class="hljs-attr">configurable</span>:<span class="hljs-literal">true</span><br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...args);<br>    <span class="hljs-keyword">let</span> result = ctx[key](...args)<br>    <span class="hljs-keyword">delete</span> ctx[key]<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">numA,numB</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-keyword">return</span> numA + numB<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;定义一个sum函数&#x27;</span><br>&#125;<br>  <br><span class="hljs-keyword">const</span> res = func.<span class="hljs-title function_">myApply</span>(sum,[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;返回值为&#x27;</span>,res);  <br></code></pre></td></tr></table></figure><h3 id="3-手写bind函数"><a href="#3-手写bind函数" class="headerlink" title="3.手写bind函数"></a>3.手写bind函数</h3><p>bind函数也可以改变函数的this值，指向第一个参数。具体用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a,b,c,d</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a,b,c,d);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">111</span><br>&#125;<br><br><span class="hljs-keyword">const</span> newFn = func.<span class="hljs-title function_">myBind</span>(<span class="hljs-string">&#x27;ctx&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)   <span class="hljs-comment">//将func里的this指向了&#x27;ctx&#x27;,并传入了1,2给a,b</span><br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">newFn</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)  <span class="hljs-comment">// 将3,4传给剩余的参数c,d</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>与call，aplly不同，bind会创建一个新的函数实例，需要再次调用函数。</p><p>手写<code>apply</code>，先从函数原型上绑定自定的myBind，核心就是获取改变调用函数的this，指向传入的第一个参数，然后获取两次传递的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>)&#123;<br>    <span class="hljs-comment">// Array.prototype.slice.call(arguments, index) 从第index个开始转换成数组，arguments继承了数组的原型方法中的slice方法</span><br>    <span class="hljs-keyword">var</span> args = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>,<span class="hljs-number">1</span>)  <span class="hljs-comment">//获得第一次除了指定this的其它参数</span><br>    <span class="hljs-keyword">var</span> fn = <span class="hljs-variable language_">this</span>  <span class="hljs-comment">// 这里的this指向调用myBind的函数，并保存传递给fn</span><br>    <span class="hljs-comment">// bind 会返回一个新的函数，所以return一个函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">//获取第二次调用时的参数</span><br>        <span class="hljs-keyword">var</span> restArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>) <br>        <span class="hljs-comment">//将两次参数拼接</span><br>        allArgs = args.<span class="hljs-title function_">concat</span>(restArgs)<br>        <span class="hljs-comment">// 接下来就是判断是否是通过new来创建函数实例的</span><br>        <span class="hljs-comment">//如果是返回new</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-variable language_">this</span>)===A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>(...allArgs)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 如果不是直接返回</span><br>            <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(ctx,allArgs)<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">const</span> newFn =func.<span class="hljs-title function_">myBind</span>(<span class="hljs-string">&#x27;ctx&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-keyword">let</span> result = <span class="hljs-keyword">new</span> <span class="hljs-title function_">newFn</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);<br></code></pre></td></tr></table></figure><p>tips：关于判断是否用new创建实例，这里要了解new创建实例的步骤，</p><p>​1.</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中的this</title>
    <link href="/2023/09/07/JS%E4%B8%AD%E7%9A%84this/"/>
    <url>/2023/09/07/JS%E4%B8%AD%E7%9A%84this/</url>
    
    <content type="html"><![CDATA[<h1 id="JS中的this"><a href="#JS中的this" class="headerlink" title="JS中的this"></a>JS中的this</h1><h3 id="如何确定this的值"><a href="#如何确定this的值" class="headerlink" title="如何确定this的值"></a>如何确定this的值</h3><h4 id="1-在全局执行环境"><a href="#1-在全局执行环境" class="headerlink" title="1.在全局执行环境"></a>1.在全局执行环境</h4><p>在全局执行环境中，严格模式和非严格模式，this都指向全局对象，浏览器中指向Window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">//--&gt;Window</span><br><br><span class="hljs-meta">&#x27;use strict&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">//--&gt;Window</span><br></code></pre></td></tr></table></figure><h4 id="2-在函数内部"><a href="#2-在函数内部" class="headerlink" title="2.在函数内部"></a>2.在函数内部</h4><h5 id="2-1直接调用"><a href="#2-1直接调用" class="headerlink" title="2.1直接调用"></a>2.1直接调用</h5><p>在函数内部直接调用，非严格模式下，this指向全局对象Window。</p><p><strong>在函数内部直接调用，严格模式下，this指向undefined。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-title function_">func</span>() <span class="hljs-comment">//--&gt;Window</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">func2</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><span class="hljs-title function_">func2</span>() <span class="hljs-comment">//--&gt;undefined</span><br></code></pre></td></tr></table></figure><h5 id="2-2对象方法调用"><a href="#2-2对象方法调用" class="headerlink" title="2.2对象方法调用"></a>2.2对象方法调用</h5><p>在函数内部用对象方法调用，严格模式和非严格模式下都指向调用者本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> food = &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;烧鸭饭&#x27;</span>,<br>      <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>      &#125;<br>&#125;<br>food.<span class="hljs-title function_">eat</span>()  <span class="hljs-comment">//--&gt;food</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">&#x27;use strict&#x27;</span><br><span class="hljs-keyword">const</span> food = &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;烧鸭饭&#x27;</span>,<br>      <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>)&#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>      &#125;<br>&#125;<br>food.<span class="hljs-title function_">eat</span>()  <span class="hljs-comment">//--&gt;food</span><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在全局执行环境中，严格模式和非严格模式，this指向Window。<strong>在函数内部直接调用，非严格模式this指向Window，严格模式this指向undefined</strong>，使用函数内部对象调用方式，严格模式和非严格模式都指向调用者。</p><h3 id="如何指定this的值"><a href="#如何指定this的值" class="headerlink" title="如何指定this的值"></a>如何指定this的值</h3><p>可以通过两类方法指定this：</p><h4 id="1-调用时指定"><a href="#1-调用时指定" class="headerlink" title="1.调用时指定"></a>1.调用时指定</h4><h5 id="1-1call方法"><a href="#1-1call方法" class="headerlink" title="1.1call方法"></a>1.1call方法</h5><p>call方法挨个传入参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">numA,numB</span>)&#123;<br><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numA,numB);<br><br> &#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> =&#123;<br><br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;along&#x27;</span><br><br>&#125;<br><br>func.<span class="hljs-title function_">call</span>(<span class="hljs-title class_">Person</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)  <span class="hljs-comment">//--&gt;Person对象 1,2</span><br></code></pre></td></tr></table></figure><p>this指向通过call方法改变成Person。</p><h5 id="1-2apply方法"><a href="#1-2apply方法" class="headerlink" title="1.2apply方法"></a>1.2apply方法</h5><p>apply方法，按数组传入参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">numA,numB</span>)&#123;<br><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br><br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numA,numB);<br><br> &#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> =&#123;<br><br> <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;along&#x27;</span><br><br>&#125;<br><br>func.<span class="hljs-title function_">apply</span>(<span class="hljs-title class_">Person</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])  <span class="hljs-comment">//--&gt;Person对象 1,2</span><br></code></pre></td></tr></table></figure><p>apply方法除了传参用数组传参，其余与call一样。</p><h4 id="2创建时指定"><a href="#2创建时指定" class="headerlink" title="2创建时指定"></a>2创建时指定</h4><h5 id="2-1bind方法"><a href="#2-1bind方法" class="headerlink" title="2.1bind方法"></a>2.1bind方法</h5><p>bind()方法主要就是将函数绑定到某个对象，bind()会创建一个函数，函数体内的this对象的值会被绑定到传入bind()第一个参数的值，当然这是绑定，不是像call、apply一样直接执行，apply要执行的话还得自己调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">numA,numB</span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numA,numB);<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> =&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;along&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> bindFunc = func.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">Person</span>,<span class="hljs-number">1</span>)  <span class="hljs-comment">//此时this变为Person并传入1</span><br><span class="hljs-title function_">bondFunc</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//再传入一个参数numB2   --&gt;Person对象 1,2</span><br></code></pre></td></tr></table></figure><h5 id="2-2箭头函数"><a href="#2-2箭头函数" class="headerlink" title="2.2箭头函数"></a>2.2箭头函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> food =&#123;<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;烧鸭饭&quot;</span>,<br>    <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>        &#125;,<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>        &#125;,<span class="hljs-number">2000</span>)<br>    &#125;<br>&#125;<br>food.<span class="hljs-title function_">eat</span>() <span class="hljs-comment">//--&gt;food Window food</span><br></code></pre></td></tr></table></figure><p>第一个<code>console.log(this)</code>打印的是调用者food，第二个打印的是全局对象Window，打三个箭头函数打印的是上一级的this，所以是food。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue2后台管理总结</title>
    <link href="/2023/06/19/vue2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <url>/2023/06/19/vue2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="vue2后台管理总结"><a href="#vue2后台管理总结" class="headerlink" title="vue2后台管理总结"></a>vue2后台管理总结</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>​这个项目已经做了挺久一段时间了，但是一直也没有花时间来总结一下，只是做完了，就不管了，前端老组长就跟我说了项目无非就是tob和toc，好吧刚听到这两个词一脸懵，他跟我解释也就是前台和中后台项目。这个后台管理项目是我第一个完整完成的，做的时候其中有一些地方没搞懂也就过去了，回过头来重新总结分析一下吧。</p><h2 id="二、前期准备"><a href="#二、前期准备" class="headerlink" title="二、前期准备"></a>二、前期准备</h2><p>Node环境</p><p>安装@vue&#x2F;cli</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i @vue/cli -g<br></code></pre></td></tr></table></figure><p>创建脚手架</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">vue <span class="hljs-keyword">create</span> 脚手架文件夹名<br></code></pre></td></tr></table></figure><h3 id="采用ElementUI组件库，网络请求axios库。"><a href="#采用ElementUI组件库，网络请求axios库。" class="headerlink" title="采用ElementUI组件库，网络请求axios库。"></a>采用ElementUI组件库，网络请求axios库。</h3><ol><li><p>下载element-ui包到当前项目(注意它支持的是Vue2版本项目)</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">npm i <span class="hljs-built_in">add</span> <span class="hljs-keyword">element</span>-ui<br></code></pre></td></tr></table></figure></li><li><p>封装新建<code>src/elementUI/index.js</code>, 在这里进行组件引入和注册</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> ElementUI <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span><br><br>Vue.use(ElementUI)<br></code></pre></td></tr></table></figure></li><li><p>在main.js中引入, 使其参与到webpack打包并在网页生效</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;@/elementUI&#x27;</span> <span class="hljs-comment">// 注册elementUI组件</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="封装请求库的思想"><a href="#封装请求库的思想" class="headerlink" title="封装请求库的思想"></a>封装请求库的思想</h3><p>封装项目的请求架构，为后面的请求数据做准备</p><p>项目管理网络请求：</p><p>1）下载axios包到当前项目的文件夹中</p><p>2）封装request请求函数配置基地址</p><p>3）封装api统一接口方法</p><p>4）在逻辑页面，需要用到哪个就引入后调用等待请求的结果，在逻辑页面使用后台返回的数据。</p><p>核心思想：<strong>分层架构</strong></p><p>在任意组件调用封装好的接口方法，接口方法调用统一的axios函数告诉他请求的参数它去请求数据。</p><p><img src="/2023/06/19/vue2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/axios.png" alt="请求结构"></p><p>安装axios：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i axios<br></code></pre></td></tr></table></figure><p>新建<code>src/utils/request.js</code>项目核心请求方法的模块文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-comment">// 创建一个自定的axios方法(比原axios多了个基地址)</span><br><span class="hljs-comment">// axios函数请求的url地址前面会被拼接基地址, 然后axios请求baseURL+url后台完整地址</span><br><span class="hljs-keyword">const</span> myAxios = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://big-event-vue-api-t.itheima.net&#x27;</span><br>&#125;)<br><br><span class="hljs-comment">// 导出自定义的axios方法, 供外面调用传参发请求</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> myAxios<br></code></pre></td></tr></table></figure><p>新建<code>src/api/index.js</code>项目接口方法的统一管理模块文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/request.js&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getList</span> = (<span class="hljs-params"></span>)=&gt;&#123;<br>    <span class="hljs-comment">// 这里先用这个接口测试下, 如果url以http开头会忽略baseURL, axios直接请求此地址</span><br><span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>        <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;http://geek.itheima.net/v1_0/channels&#x27;</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在任意组件<code>src/App.vue</code>中引入接口请求方式，并请求数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;getList&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getListFn</span>()<br>    &#125;,<br>    <span class="hljs-attr">methods</span>:&#123;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">getListFn</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getListAPI</span>()<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种分层架构思想, 可以更好的统一管理项目中所有接口, 并也方便统一给axios方法添加拦截器和修改基地址</p><h3 id="git工具的使用"><a href="#git工具的使用" class="headerlink" title="git工具的使用"></a>git工具的使用</h3><h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4><p>1.初始化本地git仓库，项目目录下有<code>.git</code>文件夹，保存git相关</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`git.init`</span><br></code></pre></td></tr></table></figure><p>2.把新建对并配置好的代码暂存，本地提交一次，产生提交记录</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 暂存当前目录下所有的变化文件，到内存中</span><br>git <span class="hljs-built_in">add</span> .<br><span class="hljs-comment"># 本地提交，才真正的被git记录一次在快照磁盘</span><br>git commit -m <span class="hljs-string">&#x27;描述&#x27;</span><br><br></code></pre></td></tr></table></figure><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>将代码保存到远程仓库里面</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git remote add <span class="hljs-built_in">origin</span> 远程仓库地址<br># 只有第一次需要-u <span class="hljs-built_in">origin</span> master ， 以后直接git <span class="hljs-built_in">push</span><br>git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master <br></code></pre></td></tr></table></figure><p>上传成功后可在远程仓库内看到</p><h4 id="新旧项目提交和推送"><a href="#新旧项目提交和推送" class="headerlink" title="新旧项目提交和推送"></a>新旧项目提交和推送</h4><p>开发代码变化后</p><p>保存本地（暂不保存到远程仓库上）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git <span class="hljs-keyword">add</span> .<br>git <span class="hljs-keyword">commit</span> -m <span class="hljs-string">&#x27;提交说明，方便回滚&#x27;</span><br></code></pre></td></tr></table></figure><p>推送到远程的话才执行</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git <span class="hljs-built_in">push</span><br></code></pre></td></tr></table></figure><h4 id="项目克隆拉取"><a href="#项目克隆拉取" class="headerlink" title="项目克隆拉取"></a>项目克隆拉取</h4><p>第一次克隆下来</p><ul><li>注意: http&#x2F;https开头的地址, 需要账号密码才能克隆&#x2F;推送</li><li>注意; git@开头的地址, 需要ssh秘钥文件配置好, 才能免账号密码克隆&#x2F;推送</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">远程git</span>仓库地址<br></code></pre></td></tr></table></figure><p>多人协同开发一个项目, 别人推送了, 以后直接拉取更新即可</p><blockquote><p>如果提示有冲突, 打开代码, 找到对方商量合并冲突</p><p>前提: 你本地有变化必须暂存提交后, 才能拉取!!!</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git pull</span><br></code></pre></td></tr></table></figure><ul><li><code>git pull</code>：必须连接远程仓库才能用。可以用于下载完整代码更新本地代码。</li><li><code>git clone</code>：只要你想往本地下远程仓库完整的代码就可以用，不用连接远程仓库（连接了也可以）。 不适用于更新本地代码。</li></ul><h2 id="项目-注册登录页面准备"><a href="#项目-注册登录页面准备" class="headerlink" title="项目-注册登录页面准备"></a>项目-注册登录页面准备</h2><p>准备注册和登录页面组件以及路由</p><p>新建注册页面组件，在<code>src/views/register/index.vue</code>中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    Reg.vue<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;my-register&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新建登录页面组件，在<code>src/views/login/index.vue</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    Login.vue<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;my-login&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在<code>src/router/index.js</code>配置路由表</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br>Vue.use(VueRouter)<br>const routes = [<br>&#123;<br>path:<span class="hljs-string">&#x27;/reg&#x27;</span>,<br>component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/register&#x27;</span>)<br>&#125;,<br>&#123;<br>path:<span class="hljs-string">&#x27;login&#x27;</span>,<br>component: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/register&#x27;</span>)<br>&#125;<br>]<br>const router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>routes<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p>在App.vue组件中，定义<code>&lt;router-view&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注册-标签布局样式布局"><a href="#注册-标签布局样式布局" class="headerlink" title="注册-标签布局样式布局"></a>注册-标签布局样式布局</h4><p><img src="/2023/06/19/vue2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/vue2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93%5C%E6%B3%A8%E5%86%8C%E9%A1%B5%E9%9D%A2.png" alt="注册页面"></p><p>在<code>src/views/register/index.vue</code>，初始化注册页面的基础布局，并美化样式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 注册页面的整体盒子 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;reg-container&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 注册的盒子 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;reg-box&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 标题的盒子 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title-box&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 注册的表单区域 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;my-register&#x27;</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.reg-container</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;../../assets/images/login_bg.jpg&#x27;</span>) center;</span><br><span class="language-css">  <span class="hljs-attribute">background-size</span>: cover;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.reg-box</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">335px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);</span><br><span class="language-css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.title-box</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;../../assets/images/login_title.png&#x27;</span>) center no-repeat;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.btn-reg</span> &#123;</span><br><span class="language-css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>查找ElementUI组件库，要完成表单组件的布局，并带上基础的校验功能</p><ul><li>1、用户名必须是1-10的大小写字母数字</li><li>2、密码必须是6-15的非空字符</li><li>3、确认密码必须和密码一致</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 注册的表单区域 --&gt;<br>&lt;el-form :model=&quot;regForm&quot; :rules=&quot;regRules&quot; ref=&quot;regRef&quot;&gt;<br>  &lt;!-- 用户名 --&gt;<br>  &lt;el-form-item prop=&quot;username&quot;&gt;<br>    &lt;el-input v-model=&quot;regForm.username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;!-- 密码 --&gt;<br>  &lt;el-form-item prop=&quot;password&quot;&gt;<br>    &lt;el-input v-model=&quot;regForm.password&quot; type=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;!-- 确认密码 --&gt;<br>  &lt;el-form-item prop=&quot;repassword&quot;&gt;<br>    &lt;el-input v-model=&quot;regForm.repassword&quot; type=&quot;password&quot; placeholder=&quot;请再次确认密码&quot;&gt;&lt;/el-input&gt;<br>  &lt;/el-form-item&gt;<br>  &lt;el-form-item&gt;<br>    &lt;el-button type=&quot;primary&quot; class=&quot;btn-reg&quot;&gt;注册&lt;/el-button&gt;<br>    &lt;el-link type=&quot;info&quot;&gt;去登录&lt;/el-link&gt;<br>  &lt;/el-form-item&gt;<br>&lt;/el-form&gt;<br><br><br>&lt;script&gt;<br>export default &#123;<br>  name: &#x27;my-register&#x27;,<br>  data () &#123;<br>    const samePwd = (rule, value, callback) =&gt; &#123;<br>      if (value !== this.regForm.password) &#123;<br>        // 如果验证失败，则调用 回调函数时，指定一个 Error 对象。<br>        callback(new Error(&#x27;两次输入的密码不一致!&#x27;))<br>      &#125; else &#123;<br>        // 如果验证成功，则直接调用 callback 回调函数即可。<br>        callback()<br>      &#125;<br>    &#125;<br>    return &#123;<br>      // 注册表单的数据对象<br>      regForm: &#123;<br>        username: &#x27;&#x27;,<br>        password: &#x27;&#x27;,<br>        repassword: &#x27;&#x27;<br>      &#125;,<br>      // 注册表单的验证规则对象<br>      regRules: &#123;<br>        username: [<br>          &#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;,<br>          &#123;<br>            pattern: /^[a-zA-Z0-9]&#123;1,10&#125;$/,<br>            message: &#x27;用户名必须是1-10的大小写字母数字&#x27;,<br>            trigger: &#x27;blur&#x27;<br>          &#125;<br>        ],<br>        password: [<br>          &#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;,<br>          &#123;<br>            pattern: /^\S&#123;6,15&#125;$/,<br>            message: &#x27;密码必须是6-15的非空字符&#x27;,<br>            trigger: &#x27;blur&#x27;<br>          &#125;<br>        ],<br>        repassword: [<br>          &#123; required: true, message: &#x27;请再次输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;,<br>          &#123; pattern: /^\S&#123;6,15&#125;$/, message: &#x27;密码必须是6-15的非空字符&#x27;, trigger: &#x27;blur&#x27; &#125;,<br>          &#123; validator: samePwd, trigger: &#x27;blur&#x27; &#125;<br>        ]<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="注册功能的实现"><a href="#注册功能的实现" class="headerlink" title="注册功能的实现"></a>注册功能的实现</h4><p>完成点击注册按钮的校验和注册功能 </p><p>核心思想：注册就是把用户输入的账号密码做好校验以后 ，收集到变量中，调用接口发送给后台，后台代码把他们存储到数据库中，再给前端返回提示</p><p>注册按钮绑定事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-button type=&quot;primary&quot; class=&quot;btn-reg&quot; @click=&quot;regNewUserFn&quot;&gt;注册&lt;/el-button&gt;<br></code></pre></td></tr></table></figure><p>事件处理函数中，执行表单验证：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">methods</span>:&#123;<br><span class="hljs-comment">// 注册新用户</span><br><span class="hljs-title function_">regNewUserFn</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">// 表单认证 </span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">regRef</span>.<span class="hljs-title function_">validate</span>(<span class="hljs-function"><span class="hljs-params">valid</span> =&gt;</span>&#123;<br><span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-comment">// 输出得到的内容</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">regForm</span>)<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 调用后台接口，在<code>src/api/index.js</code>定义</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*注册接口</span><br><span class="hljs-comment">*<span class="hljs-doctag">@param</span> &#123;*&#125; param0 &#123;username:用户名,password：密码,repassword：确认密码&#125;</span><br><span class="hljs-comment">*<span class="hljs-doctag">@returns</span> Promise对象</span><br><span class="hljs-comment">*/</span><br>export <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">registerAPI</span> = (&#123;username,password,repassword&#125;)=&gt;&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">request</span>(&#123;<br><span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;/api/reg&#x27;</span>,<br><span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br><span class="hljs-attr">data</span>:&#123;<br>username,<br>password,<br>repassword<br>&#125;<br>&#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在逻辑页面中引用接口，并在注册逻辑中调用，使用elementUI绑定在Vue全局属性上的$message弹窗方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 注册新用户</span><br>regNewUserFn()&#123;<br><span class="hljs-comment">// 进行表单验证</span><br><span class="hljs-keyword">this</span>.$refs.regRef.validate(async valid=&gt;&#123;<br><span class="hljs-keyword">if</span>(!valid) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-comment">// 调用注册接口</span><br><span class="hljs-keyword">const</span> &#123;<span class="hljs-keyword">data</span>:res&#125; = await registerAPI(<span class="hljs-keyword">this</span>.regForm)<br>console.log(res)<br><span class="hljs-comment">// 注册失败，提示用户</span><br><span class="hljs-keyword">if</span> (res.code!==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$message.error(res.message)<br><span class="hljs-comment">// 注册成功</span><br><span class="hljs-keyword">this</span>.$message.success(res.message)<br><span class="hljs-comment">// 跳转到登陆页面</span><br><span class="hljs-keyword">this</span>.$router.push(<span class="hljs-string">&#x27;/login&#x27;</span>)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>注册的业务逻辑：将前端页面标签准备好，点击事件中走完表单验证逻辑，调用接口传参给后台，根据后台返回的code做前端页面结果的展示</p><h4 id="登录标签布局和表单验证"><a href="#登录标签布局和表单验证" class="headerlink" title="登录标签布局和表单验证"></a>登录标签布局和表单验证</h4><p>在login页面准备好页面标签和样式</p><p><img src="/2023/06/19/vue2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93/vue2%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%80%BB%E7%BB%93%5C%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2.png" alt="登录页面"></p><p>登录页面和注册页面差不多，标签和校验一样，在<code>src/views/login/index.vue</code>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;!-- 登录页面的整体盒子 --&gt;<br>  &lt;div class=&quot;login-container&quot;&gt;<br>    &lt;!-- 登录的盒子 --&gt;<br>    &lt;div class=&quot;login-box&quot;&gt;<br>      &lt;!-- 标题的盒子 --&gt;<br>      &lt;div class=&quot;title-box&quot;&gt;&lt;/div&gt;<br>      &lt;!-- 登录的表单区域 --&gt;<br>      &lt;el-form :model=&quot;loginForm&quot; :rules=&quot;loginRules&quot; ref=&quot;loginRef&quot;&gt;<br>        &lt;!-- 用户名 --&gt;<br>        &lt;el-form-item prop=&quot;username&quot;&gt;<br>          &lt;el-input v-model=&quot;loginForm.username&quot; placeholder=&quot;请输入用户名&quot; maxlength=&quot;10&quot; minlength=&quot;1&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;!-- 密码 --&gt;<br>        &lt;el-form-item prop=&quot;password&quot;&gt;<br>          &lt;el-input<br>            v-model=&quot;loginForm.password&quot;<br>            type=&quot;password&quot;<br>            placeholder=&quot;请输入密码&quot;<br>            maxlength=&quot;15&quot;<br>            minlength=&quot;6&quot;<br>          &gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item&gt;<br>          &lt;el-button type=&quot;primary&quot; class=&quot;btn-login&quot;&gt;登录&lt;/el-button&gt;<br>          &lt;el-link type=&quot;info&quot;&gt;去注册&lt;/el-link&gt;<br>        &lt;/el-form-item&gt;<br>      &lt;/el-form&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>export default &#123;<br>  name: &#x27;my-login&#x27;,<br>  data () &#123;<br>    return &#123;<br>      // 登录表单的数据对象<br>      loginForm: &#123;<br>        username: &#x27;&#x27;,<br>        password: &#x27;&#x27;<br>      &#125;,<br>      // 登录表单的验证规则对象<br>      loginRules: &#123;<br>        username: [<br>          &#123; required: true, message: &#x27;请输入用户名&#x27;, trigger: &#x27;blur&#x27; &#125;,<br>          &#123; pattern: /^[a-zA-Z0-9]&#123;1,10&#125;$/, message: &#x27;用户名必须是1-10的字母数字&#x27;, trigger: &#x27;blur&#x27; &#125;<br>        ],<br>        password: [<br>          &#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;,<br>          &#123; pattern: /^\S&#123;6,15&#125;$/, message: &#x27;密码必须是6-15的非空字符&#x27;, trigger: &#x27;blur&#x27; &#125;<br>        ]<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;less&quot; scoped&gt;<br>.login-container &#123;<br>  background: url(&#x27;../../assets/images/login_bg.jpg&#x27;) center;<br>  background-size: cover;<br>  height: 100%;<br><br>  .login-box &#123;<br>    width: 400px;<br>    height: 270px;<br>    background-color: #fff;<br>    border-radius: 3px;<br>    position: absolute;<br>    left: 50%;<br>    top: 50%;<br>    transform: translate(-50%, -50%);<br>    padding: 0 30px;<br>    box-sizing: border-box;<br><br>    .title-box &#123;<br>      height: 60px;<br>      background: url(&#x27;../../assets/images/login_title.png&#x27;) center no-repeat;<br>    &#125;<br><br>    .btn-login &#123;<br>      width: 100%;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>实现注册页面，点击登录跳转效果，在<code>src/views/register/index.vue</code>，找到对应标签绑定点击事件跳转路由页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-link type=&quot;info&quot; @click=&quot;$router.push(&#x27;/login&#x27;)&quot;&gt;去登录 &lt;/el-link&gt;<br></code></pre></td></tr></table></figure><p>实现登录页面，点击注册跳转效果，在<code>src/views/login/index.vue</code>，找到对应标签绑定点击事件跳转路由页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-link type=&quot;info&quot; @click=&quot;$router.push(&#x27;/reg&#x27;)&quot;&gt;去注册 &lt;/el-link&gt;<br></code></pre></td></tr></table></figure><h4 id="登录功能实现"><a href="#登录功能实现" class="headerlink" title="登录功能实现"></a>登录功能实现</h4><p>点击登录按钮，实现登录逻辑</p><p>核心思想：通过表单校验，收集用户输入的内容，调用接口带给后台验证没返回响应结果，再给页面响应结果</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;el-button <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;primary&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;btn-login&quot;</span> @<span class="hljs-attribute">click</span>=loginFn&gt;登录&lt;/el-link&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>vue项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂感</title>
    <link href="/2023/06/18/%E6%9D%82%E6%84%9F/"/>
    <url>/2023/06/18/%E6%9D%82%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="杂感"><a href="#杂感" class="headerlink" title="杂感"></a>杂感</h1><p>好久没有更新博客了，经过和老组长交流了一下，以后要坚持持续更新，看了一眼老组长的博客，真的感慨，千里之行始于足下，回想这一学期的学习，我感觉真的学的东西太少了！虽然每天坚持到实验室打卡，不过有效学习的时间真的不多，转眼就大三了，希望能在这个暑假有所收获！加油！</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js原型与原型链</title>
    <link href="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JS原型与原型链"><a href="#一、JS原型与原型链" class="headerlink" title="一、JS原型与原型链"></a>一、JS原型与原型链</h1><h2 id="（1）JS原型"><a href="#（1）JS原型" class="headerlink" title="（1）JS原型"></a>（1）JS原型</h2><h3 id="①函数对象"><a href="#①函数对象" class="headerlink" title="①函数对象"></a>①函数对象</h3><p>​所有引用类型（Object，Array，Date，Function），都拥有__ proto__(隐式原型)属性，属性值为一个普通的对象。</p><p>​所有函数都拥有prototype属性（显示原型），为函数所特有的属性。</p><p>​原型对象：即prototype属性指向的对象叫做原型对象，当申明一个函数的时候，编译器会自动帮你创建一个与之对应的对象称为原型对象。 每个函数都有一个prototype属性,它是一个指针,指向一个对象,这个对象包含了所有实例共享的属性和方法。</p><h3 id="②构造函数"><a href="#②构造函数" class="headerlink" title="②构造函数"></a>②构造函数</h3><p>​首先先构造一个函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name,age)</span>&#123;<br>     <span class="hljs-keyword">this</span>.name=name;<br>     <span class="hljs-keyword">this</span>.age=age;<br>&#125;<br></code></pre></td></tr></table></figure><p>​往原型对象里面添加成员。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Person.prototype.eat=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br>Person.prototype.study=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="③实例化对象"><a href="#③实例化对象" class="headerlink" title="③实例化对象"></a>③实例化对象</h3><p>通过new关键字，构建p1，p2实例对象。</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">let</span> p<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> p<span class="hljs-number">2</span> = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure><p>此时p1，p2可以访问构造函数的原型上的方法，并且p1.eat &#x3D;&#x3D;&#x3D;  p2.eat。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">p1.eat()<span class="hljs-comment">;   //输出&quot;我要干饭！&quot;</span><br>console.log(p1.eat<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>p2.eat)<span class="hljs-comment">;  //输出：true</span><br></code></pre></td></tr></table></figure><p>但注意如果没有使用往原型对象里面添加成员的方法，直接在构造函数内添加方法，在通过实例化对象调用该方法，此时二者<strong>不相等</strong>！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">20</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">study</span>===p2.<span class="hljs-property">study</span>);   <span class="hljs-comment">//此时输出：false</span><br></code></pre></td></tr></table></figure><p>这是因为，构造函数的定义方法在实例对象上都创建一遍，上方代码p1和p2都有名为study的方法，但是这两个方法不是同一个Function的实例。实例共享的属性和方法都放在原型对象上，有效解决构造函数内存资源浪费 + 全局变量污染。</p><h3 id="④-proto-属性"><a href="#④-proto-属性" class="headerlink" title="④ __proto__属性"></a>④ <code>__proto__</code>属性</h3><p><code>__proto__</code>:  属于实例对象，可以让实例对象访问原型对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">__proto__</span>===<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);   <span class="hljs-comment">//此时输出：true</span><br></code></pre></td></tr></table></figure><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/01.png" alt="图1"></p><h3 id="⑤constructor属性"><a href="#⑤constructor属性" class="headerlink" title="⑤constructor属性"></a>⑤constructor属性</h3><p>constructor属性，属于原型对象，指向构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Person</span>); <span class="hljs-comment">//输出为：true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">constructor</span>===<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">//输出为：true</span><br></code></pre></td></tr></table></figure><p><code>p1.__proto__.constructor</code>可以直接写为<code>p1.constructor</code>，p1可以直接访问原型对象。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/02.png" alt="图2"></p><h2 id="（2）js原型链"><a href="#（2）js原型链" class="headerlink" title="（2）js原型链"></a>（2）js原型链</h2><h3 id="①引用一个例子"><a href="#①引用一个例子" class="headerlink" title="①引用一个例子"></a>①引用一个例子</h3><p>原型链：每一个对象都有原型，而原型也是对象，也会有自己的原型。以此类推形成链式结构，称之为原型链。</p><p>观察以下代码输出结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name,age</span>)&#123;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>     <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">eat</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要干饭！&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">study</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我要学习！&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> p1 =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>);<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span>);  <span class="hljs-comment">//输出：张三</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">age</span>);<span class="hljs-comment">//输出：18</span><br>p1.<span class="hljs-title function_">eat</span>();<span class="hljs-comment">//输出：我要干饭！</span><br>p1.<span class="hljs-title function_">toString</span>();<span class="hljs-comment">//不报错</span><br>p1.<span class="hljs-title function_">learn</span>();<span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><p>引用<code>p1.eat()</code>，p1的构造函数的原型对象有eat方法，正常输出。但是p1的构造函数的原型对象上没有learn和toString方法，引用<code>p1.learn()</code>，输出报错，调用<code>p1.toString()</code>输出却不报错。这是因为，当调用<code>p1.toString()</code>方法时，p1的构造函数的原型对象上没有toString方法，但是p1的构造函数的<strong>原型对象的原型对象上</strong>有toString方法。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/03.png" alt="图3"></p><p>检查p1原型的原型。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/04.png" alt="图4"></p><p>检查p1原型的原型的原型。</p><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/05.png" alt="图5"></p><p>发现原型链终点为<code>null</code>。</p><h3 id="②画出原型链。"><a href="#②画出原型链。" class="headerlink" title="②画出原型链。"></a>②画出原型链。</h3><p><img src="/2022/09/21/js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/06.png" alt="图6"></p><h1 id="二、总结"><a href="#二、总结" class="headerlink" title="二、总结"></a>二、总结</h1><p>（1）、我们需要牢记两点：①<code>__proto__</code>和<code>constructor</code>属性是对象所独有的；②<code>prototype</code>属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性。</p><p>（2）、<code>prototype</code>属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即p1.<code>__proto__</code> &#x3D;&#x3D;&#x3D; <code>Person.prototype</code>。</p><p>（3）、<code>__proto__</code>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<code>__proto__</code>属性所指向的那个对象（父对象）里找，一直找，直到<code>__proto__</code>属性的终点null，再往上找就相当于在null上取值，会报错。通过<code>__proto__</code>属性将对象连接起来的这条链路即我们所谓的原型链。</p><p>（4）、<code>constructor</code>属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
